use std::collections::HashMap;
use std::fmt::Write;

use anyhow::Context;
use fs_err as fs;
use heck::AsShoutySnakeCase;
use regex::Regex;
use walkdir::WalkDir;

use crate::PREFIX;

pub fn generate() -> anyhow::Result<()> {
    let mut output = String::new();

    writeln!(output, "// Generated by JoltC-generate").unwrap();

    for entry in WalkDir::new("JoltPhysics/Jolt") {
        let entry = entry?;
        let file_name = entry
            .file_name()
            .to_str()
            .context("invalid UTF-8 in file name")?;

        if file_name.ends_with(".h") {
            eprintln!("Processing {file_name}...");

            let header = fs::read_to_string(entry.path())?;

            convert_enums(&header, &mut output);
        }
    }

    println!("{output}");

    Ok(())
}

fn convert_enums(header: &str, output: &mut String) {
    struct WipEnum {
        cpp_name: String,
        c_name: String,
        shouty_c_name: String,
        next_value: u32,
        num_variants: u32,
    }

    let enum_types: HashMap<&str, &str> = HashMap::from_iter([
        ("int", "int"),
        ("uint", "unsigned int"),
        ("uint8", "uint8_t"),
        ("uint16", "uint16_t"),
        ("uint32", "uint32_t"),
    ]);

    let enum_class = Regex::new(r"^\s*enum\s+class\s+(\w+)(?:\s*:\s*(\w+))?").unwrap();
    let enum_member = Regex::new(r"^\s*(\w+)(?:\s*=\s*(.+?)(?:,|/|$))?").unwrap();
    let end_block = Regex::new(r"^\s*}").unwrap();

    let mut current_enum = None;

    for line in header.lines() {
        if current_enum.is_none() {
            if let Some(captures) = enum_class.captures(line) {
                let mut name = &captures[1];
                let given_repr = captures.get(2).map(|m| m.as_str()).unwrap_or("int");

                let repr = enum_types
                    .get(given_repr)
                    .unwrap_or_else(|| panic!("unknown enum type {given_repr}"));

                // EShapeSubType => ShapeSubType
                if name.starts_with('E') && name.as_bytes()[1].is_ascii_uppercase() {
                    name = &name[1..];
                }

                let c_name = format!("{PREFIX}_{}", name);

                let shouty_c_name =
                    format!("{}", AsShoutySnakeCase(&c_name)).replace("DO_FS", "DOFS");

                writeln!(output, "typedef {repr} {c_name};").unwrap();

                current_enum = Some(WipEnum {
                    cpp_name: name.to_owned(),
                    c_name,
                    shouty_c_name,
                    next_value: 0,
                    num_variants: 0,
                });

                continue;
            }

            continue;
        }

        if let Some(current) = &mut current_enum {
            if end_block.is_match(line) {
                writeln!(output).unwrap();

                current_enum = None;
                continue;
            }

            if let Some(captures) = enum_member.captures(line) {
                current.num_variants += 1;

                let name = &captures[1];
                let given_value = captures.get(2).map(|m| m.as_str().trim().to_string());

                if given_value.is_none() && current.num_variants > 1 && current.next_value == 0 {
                    panic!("Enum {} variant {name} did not have a value, but is set to use auto values", current.cpp_name);
                }

                let value = given_value.unwrap_or_else(|| {
                    let v = current.next_value;
                    current.next_value += 1;
                    v.to_string()
                });

                let c_name = format!("{}_{}", current.shouty_c_name, AsShoutySnakeCase(name));
                writeln!(output, "static {} {c_name} = {value};", current.c_name).unwrap();
            }
        }
    }
}
